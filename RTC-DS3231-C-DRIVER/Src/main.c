/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32_rtc.h"

#define BUFFER_SIZE		19 /* Number of registers in RTC module to be read as data stream */

/**
 * Global variable definition for STM Studio
 * VarViewer:
 */
uint16_t var_seconds;
uint16_t var_minutes;
uint16_t var_hours;
uint16_t var_day;
uint16_t var_date;
uint16_t var_month;
uint16_t var_year;

int main(void)
{
	/* Handler array definition and initialisation */
	uint8_t buffer_RTC_DS3231[BUFFER_SIZE] = {0};

	/* Clock initisalisation for I2C1 and GPIOB */
	stm_enable_clock();

	/* I2C1 peripheral configuration and initisalisation */
	stm_i2c_config();

	/**
	 * As state in the data sheet: "If the register pointer is not
     * written to before the initiation of a read mode, the first
     * address that is read is the last one stored in the regis-
     * ter pointer".
     * For that reason, the RTC DS3231 register pointer is initialised
     * to the first register (00h) before performing a stream read to be sure
     * that the correct data format is saved in the buffer_RTC_DS3231 variable
	 */
	if (STM_I2C_OK != DS3231_I2C_writePointer(RTC_REG_SEC))
	{
		for (;;); /* Loop forever is case of fail pointer setting */
	}

	/**
	 * While no error in I2C communication between STM32 and RTC DS3231,
	 * continue reading registers from RTC module beginning at 00h register
	 * ("During a multibyte access, when the address pointer reaches the
	 * end of the register space (12h), it wraps around to location 00h")
	 */
	while (STM_I2C_OK == DS3231_I2C_readStream(buffer_RTC_DS3231, BUFFER_SIZE))
	{
		var_seconds = (uint16_t) ((((buffer_RTC_DS3231[0] >> 0) & 0x0f) * 1) + (((buffer_RTC_DS3231[0] >> 4) & 0x0f) * 10));
		var_minutes = (uint16_t) ((((buffer_RTC_DS3231[1] >> 0) & 0x0f) * 1) + (((buffer_RTC_DS3231[1] >> 4) & 0x0f) * 10));
		var_hours = (uint16_t) ((((buffer_RTC_DS3231[2] >> 0) & 0x0f) * 1) + (((buffer_RTC_DS3231[2] >> 4) & 0x01) * 10));
		var_day = (uint16_t) ((buffer_RTC_DS3231[3] >> 0) & 0x07);
		var_date = (uint16_t) ((((buffer_RTC_DS3231[4] >> 0) & 0x0f) * 1) + (((buffer_RTC_DS3231[4] >> 4) & 0x03) * 10));
		var_month = (uint16_t) ((((buffer_RTC_DS3231[5] >> 0) & 0x0f) * 1) + (((buffer_RTC_DS3231[5] >> 4) & 0x01) * 10));
		var_year = (uint16_t) ((((buffer_RTC_DS3231[6] >> 0) & 0x0f) * 1) + (((buffer_RTC_DS3231[6] >> 4) & 0x0f) * 10));
	}

    /**
     * Loop forever:
     * Should never get here, otherwise error during communication
     */
	for(;;);
	return 0;
}
